<chapter id="core-jsem">
  <title>JSEM - JSOM to Search Engine Mapping</title>

  <sect1 id="jsem-introduction">
    <title>Introduction</title>
    
    <para>
      Compass provides the ability to map JSON to the underlying Search Engine through simple XML mapping files, we call this technology JSEM (JSON to Search Engine Mapping). The JSEM files are used by Compass to extract the required JSON elements at run-time and inserting the required meta-data into the Search Engine index. Mappings can be done explicitly for each JSON element, or let Compass dynamically add all JSON elements from a certain JSON element recursively.
    </para>
    
    <para>
      Lets start with a simple example. The following is a sample JSON that we will work with:
<programlisting><![CDATA[{   
    "id": 1,
    "name": "Mary Lebow",
    "address": {
      "street": "5 Main Street"
      "city": "San Diego, CA",
      "zip": 91912,
    },
    "phoneNumbers": [
      "619 332-3452",
      "664 223-4667"
    ]
  }
}
]]></programlisting>      
    </para>
    
    <para>
      Now, lets see different ways of how we can map this JSON into the search engine. The first option will be to use fully explicit mappings:
<programlisting><![CDATA[<root-json-object alias="addressbook">
    <json-id name="id" />
    <json-property name="name" />
    <json-object name="address">
        <json-property name="street" />
        <json-property name="city" />
        <json-property name="zip" index="un_tokenized" />
        <json-array name="phoneNumbers" index-name="phoneNumber">
            <json-property />
        </json-array>
    </json-object>
</root-json-object>
]]></programlisting>      
    </para>

    <para>
      The above explicit mapping defines how each JSON element will be mapped to the search engine. In the above case, we will have several searchable properties named after their respective JSON element names (the name can be changed by using <literal>index-name</literal> attribute). We can now perform search queries such as <literal>street:diego</literal>, or <literal>phoneNumber:619*</literal>, or even (using dot path notation): <literal>addressbook.address.street:diego</literal>.
    </para>
    
    <para>
      Many times though, explicit mapping of all the JSON elements is a bit of a pain, and does not work when wanting to create a generic indexing service. In this case, Compass allows to dynamically and recursively map JSON element. Here is an example where the JSON <literal>address</literal> element is mapped dynamically, thus adding any element within it dynamically to the search engine:
<programlisting><![CDATA[<root-json-object alias="addressbook">
    <json-id name="id" />
    <json-property name="name" />
    <json-object name="address" dynamic="true" />
</root-json-object>
]]></programlisting>      
    </para>
    
    <para>
      The dynamic aspect can even be set on the <literal>root-json-object</literal> allows to create a completely generic JSON indexing service which requires only setting the id JSON element.
    </para>
    
    <para>
      Now, in order to index, search, and load JSON objects, we can use the <classname>JsonObject</classname> API abstraction. Here is a simple example that uses a <classname>JsonObject</classname> implementation that is bundled with Compass called <classname>JSONObject</classname> and is based on the <literal>json.org</literal> site:
<programlisting><![CDATA[JsonObject jsonObject = new DefaultAliasedJSONObject("addressbook", "json string goes here");
// this will index the provided JSON
session.save(jsonObject);

// now we can load the Resource that represents it
Resource resource = session.loadResource("addressbook", 1);
resource.getValue("name"); // will get Mary Lebow

// we can also get back the JSON content and actual object when using content mapping (see later)
jsonObject = (JsonObject) session.load("addressbook", 1);

// Last, we can search
CompassHits hits = session.find("mary");
hits.lenght() // will print one
resource = hits.resource(0);
jsonObject = (JsonObject) hits.data(0);
]]></programlisting>      
    </para>

  </sect1>
  
  <sect1 id="jsem-api-abstraction">
    <title>JSON API Abstraction</title>
    
    <para>
      Since there is no single object based API when working with JSON Compass has an interface based abstraction that can be used with any JSON implementation available. The APIs can be found under <literal>org.compass.core.json</literal> and include <classname>JsonObject</classname>, <classname>AliasedJsonObject</classname>, and <classname>JsonArray</classname>. Compass comes with several built in implementations. The first is taken from <literal>json.org</literal> site and is bundled with Compass under <literal>org.compass.core.json.impl</literal>. The second supports Grails JSON objects and has wrapper implementations around it under <literal>org.compass.core.json.grails</literal>. The last supports Jettison JSON objects and has a wrapper implementation around it under <literal>org.compass.core.json.jettison</literal>.
    </para>
    
    <para>
      Implementing support for another framework that bundles its own JSON object based implementation should be very simple. It should basically follow the API requirements (probably by wrapping the actual one). The jettison implementation can be used as a reference implementation on how this can be done. 
    </para>
  </sect1>
  
  <sect1 id="jsem-content-mapping">
    <title>Content Mapping</title>
    
    <para>
      By default, when mapping JSON using Compass, the JSON content itself is not stored in the search engine. If the JSON content itself is not store, then when searching and getting back results from the search engine only <classname>Resource</classname> can be used. Within the mapping definition, the actual JSON content can be store. This allows to get the JSON itself from the search engine using the <classname>Resource</classname> API, as well as converting back the search results into the actual JSON object (jettison, grails, the default, or a custom one).
    </para>
    
    <para>
      The following mapping definition shows how to map JSON to also store its content:
<programlisting><![CDATA[<root-json-object alias="addressbook">
    <json-id name="id" />
    <json-property name="name" />
    <json-object name="address" dynamic="true" />
    <json-content name="content" />
</root-json-object>
]]></programlisting>      
    </para>
    
    <para>
      This will cause Compass to store the actual JSON content under a Resource Property named content. Here is an example of how it can be retrieved back from the search engine:
<programlisting><![CDATA[Resource resource = session.loadResource("addressbook", 1);
resource.getValue("content"); // will get actual json string
]]></programlisting>      
    </para>
    
    <para>
      In order to convert back to the actual JSON object, a converter instructing Compass how to convert the JSON string back to your favorite JSON object model should be registered with Compass. For example, to register the jettison based converter, the setting named <literal>compass.jsonContentConverter.type</literal> should be set to <literal>org.compass.core.json.jettison.converter.JettisonContentConverter</literal>. In order to register the grails converter the setting should be set to <literal>org.compass.core.json.grails.converter.GrailsContentConverter</literal>. And, in order to use the default build in Compass implementation the setting should be set to <literal>org.compass.core.json.impl.converter.DefaultJSONContentConverterImpl</literal>.
    </para>
    
    <para>
        By default, the content converter registered with Compass is the default one.
    </para>
  </sect1>
  
  <sect1 id="jsem-raw-json-object">
    <title>Raw Json Object</title>
    
    <para>
      When configuring a JSON content converter, Compass now knows how to convert a <classname>JsonObject</classname> to and from a JSON string. This allows to use Compass <classname>RawJsonObject</classname> and <classname>RawAliasedJsonObject</classname>. The raw json objects are simple JSON string holders that are then converted by Compass automatically when saved into the preferred <classname>JsonObject</classname>. This simplifies saving JSON objects by just constructing the raw objects based on json strings. Here is an example:
<programlisting><![CDATA[JsonObject jsonObject = new RawAliasedJsonObject("addressbook", "json string goes here");
// this will index the provided JSON
session.save(jsonObject);
]]></programlisting>      
    </para>
  </sect1>
</chapter>
