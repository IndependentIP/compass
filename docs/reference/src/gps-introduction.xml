<chapter id="gps-introduction"> <title>Introduction</title>

    <sect1 id="gps-overview">
      <title>Overview</title>

      <para>
        Compass::Gps provides integration with different indexable data sources using two concepts: <emphasis>CompassGps</emphasis> and <emphasis>CompassGpsDevice</emphasis>. Both the interfaces are very abstract, since different data sources are usually different in the way they work or the API they expose.
      </para>

      <para>
        A device is considered to be any type of indexable data source imaginable, from a database (maybe through the use of an ORM mapping tool), file system, ftp site, or a web site.
      </para>

      <para>
        The main contract that a device is required to provide is the ability to index it's data (using the <literal>index()</literal> operation). You can think of it as batch indexing the datasource data,  providing access for future search queries. An additional possible operation that a device can implement is mirror data changes, either actively or passively.
      </para>

      <para>
        When performing the index operation, it is very important NOT to perform it within an already running transaction. For <literal>LocalTransactionFactory</literal>, no outer <literal>LocalTransaction</literal> should be started. For <literal>JTATransactionFactory</literal>, no JTA transaction must be started, or no CMT transaction defined for the method level (on EJB Session Bean for example). For <literal>SpringSyncTransactionFactory</literal>, no spring transaction should be wrapping the index code, and the executing method should not be wrapped with a transaction (using transaction proxy for example).
      </para>

      <para>
        Compass::Gps is built on top of Compass::Core, utilizing all it's features such as transactions (including the important <literal>batch_insert</literal> level for batch indexing), OSEM, and the simple API that comes with Compass::Core.
      </para>

    </sect1>

    <sect1 id="gps-CompassGps">
      <title>CompassGps</title>

      <para>
        <literal>CompassGps</literal> is the main interface of Compass::Gps. It holds a list of <literal>CompassGpsDevice</literal>s, and manages their lifecycle.
      </para>

      <para>
        <literal>CompassGpsInterfaceDevice</literal> is an extension of <literal>CompassGps</literal>, and provides the needed abstration between the <literal>Compass</literal> instance/s and the given devices. Every implementation of a <literal>CompassGps</literal> must also implement the <literal>CompassGpsInterfaceDevice</literal>. Compass::Gps comes with two implementations of <literal>CompassGps</literal>:
      </para>

      <sect2 id="gps-SingleCompassGps">
          <title>SingleCompassGps</title>

          <para>
            Holds a single <literal>Compass</literal> instance. The <literal>Compass</literal> instance is used for both the index operation and the mirror operation. When executing the index operation, the implementation will not use the configured transaction isolation, but will use the <literal>indexTransactionIsolation</literal> transaction isolation property, which defaults to <literal>batch_insert</literal>. You can also set additional settings to be used with the cloned index compass (a prime example is when using jdbc storage, but defining a file location for the indexing compass, thus gaining performance improvement).
          </para>

          <para>
            When calling the index operation on the <literal>SingleCompassGps</literal>, it will gracefully replace the current index (pointed by the initialized single <literal>Compass</literal> instance), with the content of the index operation. Gracefully means that while the index operation is executing and building a temporary index, no write operations will be allowed on the actual index, and while the actual index is replaced by the temporary index, no read operations are allowed as well.
          </para>
      </sect2>

      <sect2 id="gps-DualCompassGps">
          <title>DualCompassGps</title>

          <para>
            Holds two <literal>Compass</literal> instances. One, called <literal>indexCompass</literal> is responsible for index operation. The other, called <literal>mirrorCompass</literal> is responsible for mirror operations. The main reason why we have two different instances is because the transaction isolation level can greatly affect the performance of each operation. Usually the <literal>indexCompass</literal> instance will be configured with the <literal>batch_insert</literal> isolation level, while the <literal>mirrorCompass</literal> instance will use the default transaction isolation level (<literal>read_committed</literal>).
          </para>

          <para>
            When calling the index operation on the <literal>DualCompassGps</literal>, it will gracefully replace the mirror index (pointed by the initialized <literal>mirrorCompass</literal> instance), with the content of the index index (pointed by the initialized <literal>indexCompass</literal> instance). Gracefully means that while the index operation is executing and building the index, no write operations will be allowed on the mirror index, and while the mirror index is replaced by the index, no read operations are allowed as well.
          </para>
      </sect2>

        <para>
            Both implementations of <literal>CompassGps</literal> allow to set / override settings of the <literal>Compass</literal> that will be responsible for the index process. One sample of using the feature which might yield performance improvements can be when storing the index within a database. The indexing process can be done on the local file system (on a temporary location), in a compound format (or non compound format), by setting the indexing compass connection setting to point to a file system location. Both implementations will perform "hot replace" of the file system index into the database location, automatically compounding / uncompounding based on the settings of both the index and the mirror compass instances. 
        </para>

    </sect1>

    <sect1 id="gps-CompassGpsDevice">
      <title>CompassGpsDevice</title>

      <para>
        A Gps devices must implement the <literal>CompassGpsDevice</literal> interface in order to provide device indexing. It is responsible for interacting with a data source and reflecting it's data in the Compass index. Two examples of devices are a file system and a database, accessed through the use of a ORM tool (like Hibernate).
      </para>

      <para>
        A device will provide the ability to index the data source (using the <literal>index()</literal> operation), which usually means iterating through the device data and indexing it. It might also provide "real time" monitoring of changes in the device, and applying them to the index as well.
      </para>

      <para>
        A <literal>CompassGpsDevice</literal> cannot operate standalone, and must be a part of a <literal>CompassGps</literal> instance (even if we have only one device), since the device requires the <emphasis>Compass</emphasis> and instance(s) in order to apply the changes to the index.
      </para>

      <para>
        Each device has a name associated with it. A device name must be unique across all the devices within a single CompassGps instance.
      </para>

            <sect2 id="gps-MirrorDataChangesGpsDevice">
                <title>MirrorDataChangesGpsDevice</title>

                <para>
                    As mentioned, the main operation in <literal>CompassGpsDevice</literal> is <literal>index()</literal>, which is responsible for batch indexing all the relevant data in the data source. Gps devices that can mirror real time data changes made to the data source by implementing the <literal>MirrorDataChangesGpsDevice</literal> interface (which extends the <literal>CompassGpsDevice</literal> interface).
                </para>

                <para>
                    There are two types of devices for mirroring data. <literal>ActiveMirrorGpsDevice</literal> provides data mirroring of the datasource by explicit programmatic calls to <literal>performMirroring</literal>. <literal>PassiveMirrorGpsDevice</literal> is a GPS device that gets notified of data changes made to the data source, and does not require user intervention in order to reflect data changes to the compass index.
                </para>

                <para>
                    For <literal>ActiveMirrorGpsDevice</literal>, Compass::Gps provides a <literal>ScheduledMirrorGpsDevice</literal> class, which wraps an <literal>ActiveMirrorGpsDevice</literal> and schedules the execution of the <literal>performMirror()</literal> operation.
                </para>

            </sect2>

    </sect1>

    <sect1 id="gps-ProgrammaticConfiguration">
      <title>Programmatic Configuration</title>

      <para>
        Configuration of Compass::Gps is achieved by programmatic configuration or through an IOC container. All the devices provided by Compass::Gps as well as <literal>CompassGps</literal> can be configured via Spring framework.
      </para>

      <para>
        The following code snippet shows how to configure Compass::Gps as well as managing it's lifecycle.
<programlisting><![CDATA[Compass compass = ... // configure compass
CompassGps gps = new SingleCompassGps(compass);
CompassGpsDevice device1 = ... // configure the first device
device1.setName("device1");
gps.addDevice(device1);
CompassGpsDevice device2 = ... // configure the second device
device2.setName("device2");
gps.addDevice(device2);

gps.start();
....
....
//on application shutdown
gps.stop();
]]></programlisting>
      </para>

    </sect1>

    <sect1 id="gps-BuildingGpsDevice">
      <title>Building a Gps Device</title>

      <para>
        If you wish to build your own Gps Device, it could not be simpler (actually, it is as simple as getting the data from the data source or monitoring the data sorce data changes). The main API that a device must implement is <literal>index()</literal> which by contract means that all the relevant data for indexing in the data source is indexed.
      </para>

      <para>
        If you wish to perform real time mirroring of data changes from the data source to the index, you can controll the lifecycle of the mirroring using the <literal>start()</literal> and <literal>stop()</literal> operations, and must implement either the <literal>ActiveMirrorGpsDevice</literal> or the <literal>PassiveMirrorGpsDevice</literal> interfaces.
      </para>

      <para>
        Compass::Gps comes with a set of base classes for gps devices that can help the development of new gps devices.
      </para>

    </sect1>

</chapter>
