<chapter id="core-searchengine">
  <title>Search Engine</title>

    <sect1 id="core-searchengine-introduction">
      <title>Introduction</title>

      <para>
        Compass::Core provides an abstraction layer on top of the wonderful <ulink url="http://lucene.apache.org">Lucene</ulink> Search Engine. Compass::Core also provides several additional features on top of Lucene, like two phase transaction management, fast updates, and optimizers. When trying to explain how Compass::Core works with the Search Engine, first we need to understand the Search Engine domain model.
      </para>
    </sect1>

    <sect1 id="core-searchengine-AliasResourceProperty">
      <title>Alias, Resource and Property</title>

      <para>
        <literal>Resource</literal> represents a collection of properties. You can think about it as a virtual document - a chunk of data, such as a web page, an email message, or a serialization of the Author object. A <literal>Resource</literal> is always associated with a single Alias and
        several <literal>Resource</literal>s can have the same Alias. A <literal>Property</literal> is just a place holder for a name and value (both strings). A <literal>Property</literal> within a <literal>Resource </literal> represents some kind of meta-data that is associated with the
        <literal>Resource</literal> like the author name. In data-base terms, you can think of an Alias as a table, the <literal>Resource</literal> as a row in the table and <literal>Property</literal> as the column (with a value). Note: a <literal>Resource</literal> can have several properties with the same name.
      </para>

      <para>
        Every <literal>Resource</literal> is associated with one or more id properties. They are required for Compass::Core to manage <literal>Resource</literal> loading based on ids and <literal>Resource</literal>
        updates (a well known difficulty when using Lucene directly). Id properties are defined either explicitly in the Resource Mapping definition or implicitly in the OSEM definition.
      </para>

      <para>
        For Lucene users, Compass <literal>Resource</literal> maps to Lucene <literal>Document</literal> and Compass <literal>Property</literal> maps to Lucene <literal>Field</literal>.
      </para>

    </sect1>

    <sect1 id="core-searchengine-CreatingResourceProperty">
      <title>Creating Resource and Property</title>

      <para>
        In order to create a <literal>Resource</literal> and a <literal>Property</literal>, you use the <literal>CompassSession</literal> which acts as a factory. <literal>CompassSession</literal> provides several API's:

        <itemizedlist>
          <listitem>
            <para>
              <literal>createResource(String alias)</literal>: Creates a <literal>Resource</literal> with the specified alias.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>createProperty(String name, String value, Property.Store store, Property.Index index)</literal>: Creates a <literal>Property</literal> with the specified name and value. As well as
              the <literal>Property</literal> behavioural aspect within the Search Engine.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>createProperty(String name, String value, Property.Store store, Property.Index index, Property.TermVector termVector)</literal>: Creates a <literal>Property</literal> with the specified name and value. As well as the <literal>Property</literal> behavioural aspect within the Search Engine.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        When creating a <literal>Property</literal>, you must specify the <literal>store</literal> and the <literal>index</literal> parameters.
      </para>

      <para>
        Another option when creating <literal>Resource</literal> <literal>Property</literal> is to define resource mapping and within it a <literal>resource-id</literal> and <literal>resource-property</literal> mappings (please see the <link linkend="core-resourcemaping">Resource Mapping Section</link>). When defining the mappings, Compass can be smart enough to guess the type, index, store, and other options using the mappings, allowing the usage of the simple <literal>addProeprty(String propertyName, Object value)</literal> API of <literal>Resource</literal> (even auto converting the Object to the correct value using Compass converter architecture).
      </para>

      <para>
        The following table specifies the available values for the <literal>store</literal> parameter:

        <table>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="3*" />
            <colspec colname="c2" colwidth="5*" />
            <thead>
              <row>
                <entry>Store</entry><entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>Property.Store.NO</literal></entry>
                <entry>Do not store the property value in the index (won't be able to retrieve it later on).</entry>
              </row>
              <row>
                <entry><literal>Property.Store.YES</literal></entry>
                <entry>Stores the original property value in the index.</entry>
              </row>
              <row>
                <entry><literal>Property.Store.COMPRESS</literal></entry>
                <entry>Stores the original property value in the index in a compressed form.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      </para>

      <para>
        The following table specifies the available values for the <literal>index</literal> parameter:

        <table>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="3*" />
            <colspec colname="c2" colwidth="5*" />
            <thead>
              <row>
                <entry>Index</entry><entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>Property.Index.NO</literal></entry>
                <entry>Do not index the property value. This property can thus not be searched, but one can still access its contents provided it is stored.</entry>
              </row>
              <row>
                <entry><literal>Property.Index.TOKENIZED</literal></entry>
                <entry>Index the property value so it can be searched. An Analyzer will be used to tokenize and possibly further normalize the text before its terms will be stored in the index.</entry>
              </row>
              <row>
                <entry><literal>Property.Index.UN_TOKENIZED</literal></entry>
                <entry>Index the property value without using an Analyzer, so it can be searched. As no analyzer is used, the value will be stored as a single term (perfect for id like properties).</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      </para>

      <para>
        The following table specifies the available values for the <literal>termVector</literal> parameter:

        <table>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="5*" />
            <colspec colname="c2" colwidth="3*" />
            <thead>
              <row>
                <entry>Term Vector</entry><entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>Property.TermVector.NO</literal></entry>
                <entry>Do not store any term vector information (the default behavior).</entry>
              </row>
              <row>
                <entry><literal>Property.TermVector.YES</literal></entry>
                <entry>Store the term vectors of each document. A term vector is a list of the resources's terms and their number of occurences in that document.</entry>
              </row>
              <row>
                <entry><literal>Property.TermVector.WITH_POSITIONS</literal></entry>
                <entry>Store the term vector + Token offset information.</entry>
              </row>
              <row>
                <entry><literal>Property.TermVector.WITH_OFFSETS</literal></entry>
                <entry>Store the term vector + Token offset information.</entry>
              </row>
              <row>
                <entry><literal>Property.TermVector.WITH_POSITIONS_OFFSETS</literal></entry>
                <entry>Store the term vector + Token position and offset information.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      </para>

      <para>The following code shows how you can create a <literal>Resource</literal> with Compass::Core and save it.
<programlisting><![CDATA[CompassSession session = compass.openSession();
CompassTransaction tx = session.beginTransaction();
Resource authorResource = session.createResource("author");
Property authorIdProp = session.createProperty("id", "AUTHOR0812",
     Property.Store.YES, Property.Index.UN_TOKENIZED);
Property authorNameProp = session.createProperty("name",
     "Jack London", Property.Store.YES, Property.Index.TOKENIZED);
authorResource.addProperty(authorIdProp);
authorResource.addProperty(authorNameProp);
session.save(resource);
tx.commit();
]]></programlisting>
      </para>

    <sect2 id="core-searchengine-BoostingResourceProperty">
      <title>Boosting Resource and Property</title>

      <para>
        Compass::Core allows you to set the boosting factor for <literal>Resource</literal> and <literal>Property</literal> (through Lucene boosting feature). Boosting is the process of making a <literal>Resource
        </literal> or a <literal>Property</literal> more or less "important" than others.
      </para>

      <para>
        Initially, <literal>Resource</literal> and <literal>Property</literal> have no boost (actually, a boost of 1.0). You can set the boost level on a <literal>Resource</literal> (which propagates to all the properties that have no boosting set) or on a specific <literal>Property</literal>. Higher values than 1.0 makes it more relevant and values lower than 1.0 make it less relevant.
      </para>

    </sect2>

  </sect1>

  <sect1 id="core-searchengine-analyzers">
    <title>Analyzers</title>

    <para>
      <literal>Analyzer</literal>s are components that pre-process input text. They are also used when searching (the search string has to be processed the same way that the indexed text was processed). Therefore, it is important to use the same <literal>Analyzer</literal> for both indexing and searching.
    </para>

    <para>
      Compass::Core can be configured to have multiple analyzers, registered under different analyzer names. It has two internal analyzers: <literal>default</literal> and <literal>search</literal>, as defined in the <link linkend="core-configuration-searchengineanalyzers">Analyzers section</link> in the Configuration chapter.
    </para>

    <para>
      <literal>Analyzer</literal> is a Lucene class (which qualifies to <literal>org.apache.lucene.analysis.Analyzer</literal> class). Lucene core itself comes with several <literal>Analyzer</literal>s and you can configure Compass::Core to work with either one of them. If we take the following sentence: "The quick brown fox jumped over the lazy dogs", we can see how the different <literal>Analyzer</literal>s handle it:
    </para>

    <para>
      <literal>whitespace</literal> (<literal>org.apache.lucene.analysis.WhitespaceAnalyzer</literal>)
    </para>
    <para>
      [The] [quick] [brown] [fox] [jumped] [over] [the] [lazy] [dogs]
    </para>
    <para>
      <literal>simple</literal> (<literal>org.apache.lucene.analysis.SimpleAnalyzer</literal>)
    </para>
    <para>
      [the] [quick] [brown] [fox] [jumped] [over] [the] [lazy] [dogs]
    </para>
    <para>
      <literal>stop</literal> (<literal>org.apache.lucene.analysis.StopAnalyzer</literal>)
    </para>
    <para>
      [quick] [brown] [fox] [jumped] [over] [lazy] [dogs]
    </para>
    <para>
      <literal>standard</literal> (<literal>org.apache.lucene.analysis.standard.StandardAnalyzer</literal>)
    </para>
    <para>
      [quick] [brown] [fox] [jumped] [over] [lazy] [dogs]
    </para>
    <para>
      <literal>Analyzer</literal>s have a list of stop words which they exclude while analyzing, you can control both the <literal>Analyzer</literal> and the stop words using Compass::Core configuration parameters.
    </para>

  </sect1>

  <sect1 id="core-searchengine-indexstructure">
    <title>Index Structure</title>

    <para>
      It is very important to understand how the Search Engine index is organized so we can than talk about transaction and optimizers. The following structure shows the Search Engine Index Structure:
<programlisting><![CDATA[---[index dir]/index
  |
  |-- [subIndex1]
  |      |
  |      |--- segments
  |      |--- [segment1]
  |      |--- [segment2]
  |
  |-- [subIndex2]
  |      |
  |      |--- segments
  |      |--- [segment1]
  |      |--- [segment2]
  |      |--- [segment3]
  |
...
]]></programlisting>
    </para>

    <para>
        Every sub-index has it's own fully functional index structure (which maps to a single Lucene index). Each <literal>Resource</literal> alias is associated with a sub-index, and more than one alias can be mapped to a sub-index (using either resource mapping or OSEM). The Lucene index part holds a "meta data" file about the index (called <literal>segments</literal>) and 0 to N segment files. The segments can be a single file (if the compound setting is enabled) or multiple files (if the compound setting is disable). A segment is close to a fully functional index, which hold the actual inverted index data (see <ulink url="http://lucene.apache.org">Lucene</ulink> documentation for a detailed description of these concepts).
    </para>
  </sect1>

  <sect1 id="core-searchengine-transaction">
    <title>Transaction</title>

    <para>
      Compass:Core Search Engine abstraction provides support for transaction management on top of Lucene. The abstraction support common transaction levels: <literal>read_committed</literal> and <literal>serializable</literal>, as well as the special <literal>batch_insert</literal> one. Compass::Core provides two phase commit support for the common transaction levels only.
    </para>

        <sect2 id="Locking">
            <title>Locking</title>

            <para>
                Compass::Core utilizes Lucene inter and outer process locking mechanism and uses them to establish it's transaction locking. Note that the transaction locking is on the "sub-index" level (the sub-
                index based index), which means that dirty operations only lock their respective sub-index index. So the more aliases map to the same index, the more aliases will be locked when performing dirty operations, yet
                the faster the searches will be. Lucene uses a special lock file to manage the inter and outer process locking which can be set in the Compass::Core configuration. You can manage the transaction timeout and polling interval using the Compass::Core configuration.
            </para>

            <para>
                The Compass::Core transaction acquires a lock only when a dirty (i.e. <literal>create</literal>, <literal>save</literal> or <literal>delete</literal>) operation occurs, which makes "read only" transactions as fast as they should and can be.
            </para>

        </sect2>

        <sect2 id="read_committed">
            <title>read_committed</title>

            <para>
                Compass::Core provides support for <literal>read_committed</literal> transaction level. When starting a <literal>read_committed</literal> transaction, no locks are obtained. Read operation will not obtain a
                lock either. A lock will be obtained only when a dirty operation is performed. The lock is obtained only on the index of the alias that is associated with the dirty operation, i.e the sub-index, and will lock
                all other aliases that map to that sub-index. In Compass::Core, every transaction that performed one or more <literal>save</literal> or <literal>create</literal> operation, and committed successfully,
                creates another segment in the respective index (different than how Lucene manages it's index), which helps in implementing quick transaction commits, as well as paving the way for a two phase commit support (and the reason behind having optimizers).
            </para>

        </sect2>

        <sect2 id="serializable">
            <title>serializable</title>

            <para>
                The <literal>serializable</literal> transaction level operates the same as the <literal>read_committed</literal> transaction level, except that when the transaction is opened/started, a lock is acquired
                on all the sub-indexes. This causes the transactional operations to be sequential in nature (as well as being a performance killer).
            </para>
        </sect2>

        <sect2 id="batch_insert">
            <title>batch_insert</title>

            <para>
                A special transaction level, <literal>batch_insert</literal> utilizes the extremely fast batch indexing provided by Lucene. The transaction supports only <literal>create</literal> operation, but note that if
                another <literal>Resource</literal> with the same alias and ids already exists in the system, you will have two instances of it in the index (in other words, <literal>create</literal> doesn't delete the
                old <literal>Resource</literal>). You can control the <literal>batch_insert</literal> transaction using several settings which are explained in the Configuration section. An important note is that the
                transaction is not a transaction which can be rolled back, since Lucene commits the changes during the batch indexing process, which means that a <literal>rollback</literal> operation won't rollback the
                changes. The index is optimized when the transaction is committed, which means that all the segments are merged to one segment, in order to provide fast searching. The transaction is mainly used for background batch indexing.
            </para>

        </sect2>

  </sect1>

  <sect1 id="core-searchengine-optimizers">
    <title>Optimizers</title>

    <para>
      As mentioned in the <literal>read_committed</literal> section, every dirty transaction that is committed successfully creates another segment in the respective index. The more segments the index has, the slower the fetching operations take. That's why it is important to keep the index optimized and with a controlled number of segments. We do this by merging small segments into larger segments.
    </para>

    <para>
      In order to solve the problem, Compass::Core has a <literal>SearchEngineOptimizer</literal> which is responsible for keeping the number of segments at bay. When <literal>Compass</literal> is built using
      <literal>CompassConfiguration</literal>, the <literal>SearchEngineOptimizer</literal> is started and when the <literal>Compass</literal> is closed, the <literal>SearchEngineOptimizer</literal> is
      stopped.
    </para>

    <sect2 id="ScheduledOptimizers">
      <title>Scheduled Optimizers</title>
      <para>
        Compass::Core provides support for scheduled optimizers. The scheduled optimizers uses Java <literal>Timer</literal> to control it's execution. <literal>SearchEngineOptimizer</literal> starts and stops the
        timer when it starts and stops. There are several settings parameters that can be set to control the scheduling.
      </para>

      <para>
        Note: each optimizer that Compass provides can be scheduled.
      </para>

    </sect2>

    <sect2 id="AggressiveOptimizer">
      <title>Aggressive Optimizer</title>

      <para>
        The <literal>AggressiveOptimizer</literal> uses Lucene optimization feature to optimize the index. Lucene optimization merges all the segments into one segment. You can set the limit of the number of
        segments, after which the index is considered to need optimization (the aggressive optimizer merge factor).
      </para>

    </sect2>

    <sect2 id="AdaptiveOptimizer">
      <title>Adaptive Optimizer</title>

      <para>
        The <literal>AdaptiveOptimizer</literal> uses optimize the segments while trying to manage the optimization time at bay. As an example, when we have a large segment in our index (for example, after we batched indexed the data), and we perform several interactive transactions, the
        aggressive optimizer will than merge all the segments together, while the adaptive optimizer will only merge the new small segments. You can set the limit of the number of segments, after which the index is considered to need optimization (the adaptive optimizer merge factor).
      </para>

    </sect2>

    <sect2 id="NullOptimizer">
      <title>Null Optimizer</title>

      <para>
        Compass::Core also comes with a <literal>NullOptimizer</literal>, which performs no optimizations. It is mainly there if the hosting application developed it's own optimization which is maintained by other
        means than the <literal>SearchEngineOptimizer</literal>. It also makes sense to use it when configuring a <literal>Compass</literal> instance with a <literal>batch_insert</literal> transaction.
      </para>

      <para>
        Note that when using the <literal>NullOptimizer</literal> it makes no sense to use the scheduling feature, so remember to set the <literal>compass.engine.optimizer.schedule</literal> to <literal>false</literal>.

      </para>

    </sect2>

  </sect1>

</chapter>






