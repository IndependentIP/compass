<chapter id="core-xsem">
    <title>XSEM - Xml to Search Engine Mapping</title>

    <sect1 id="xsem-introduction">
      <title>Introduction</title>

      <para>
        Compass::Core provides the ability to map XML structure to the underlying Search Engine through simple XML mapping files, we call this technology XSEM (XML to Search Engine Mapping). XSEM provides a rich syntax for describing XML mappings using Xpath expressions. The XSEM files are used by Compass to extract the required xml elements from the xml structure at run-time and inserting the required meta-data into the Search Engine index.
      </para>
      
   </sect1>
      
   <sect1 id="xsem-xmlobject-def">
      <title>Xml Object</title>
      
      <para>
         At the core of XSEM supports is <literal>XmlObject</literal> abstraction on top of the actual XML library implementation. The <literal>XmlObject</literal> represents an XML element (document, node, attribute, ...) which is usually the result of an Xpath expression. It allows to get the name and value of the given element, and execute Xpath expressions against it (for more information please see the <literal>XmlObject</literal> javadoc).
      </para>
      
      <para>
         Here is an example of how <literal>XmlObject</literal> is used with Compass:
<programlisting><![CDATA[CompassSession session = compass.openSession();
// ...
XmlObject xmlObject = // create the actual XmlObject implementation (we will see how soon)
session.save("alias", xmlObject);
]]></programlisting>
      </para>
      
      <para>
         An extension to the <literal>XmlObject</literal> interface is the <literal>AliasedXmlObject</literal> interface. It represents an xml object that is also associated with an alias. This means, that saving the object does not require to explicitly specify the alias that it will be saved under.
<programlisting><![CDATA[CompassSession session = compass.openSession();
// ...
AliasedXmlObject xmlObject = // create the actual XmlObject implementation (we will see how soon)
session.save(xmlObject);
]]></programlisting>
      </para>

      <para>
         Compass comes with support for dom4j and JSE 5 xml libraries, here is an example of how to use dom4j API in order to create a dom4j xml object:
<programlisting><![CDATA[CompassSession session = compass.openSession();
// ...
SAXReader saxReader = new SAXReader();
Document doc = saxReader.read(new StringReader(xml));
AliasedXmlObject xmlObject = new Dom4jAliasedXmlObject(alias, doc.getRootElement());
session.save(xmlObject);
]]></programlisting>
      </para>
      <para>
         And here is a simple example of how to use JSE 5:
<programlisting><![CDATA[CompassSession session = compass.openSession();
// ...
Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(new StringReader(xml)));
AliasedXmlObject xmlObject = NodeAliasedXmlObject(alias, doc);
session.save(xmlObject);
]]></programlisting>
      </para>

    </sect1>
    
    <sect1 id="xsem-xmlcontent-def">
       <title>Xml Content Handling</title>

       <para>
          Up until now, Compass has no knowledge of how to parse and create an actual <literal>XmlObject</literal> implementation, or how to convert an <literal>XmlObject</literal> into its xml representation. This is perfectly fine, but it also means that systems will not be able to work with <literal>XmlObject</literal> for read/search operations. Again, this is perfectly ok for some application, since they can always work with the underlying <literal>Resource</literal> representation, but some applications would still like to store the actual xml content in the search engine, and work with the <literal>XmlObject</literal> for read/search operations.
       </para>
       
       <para>
          Compass XSEM support allows to define the <literal>xml-content</literal> mapping (defined below), which will cause Compass to store the xml representation in the search engine as well. It will also mean that for read/search operations, the application will be able to get an <literal>XmlObject</literal> back (for example, using <literal>CompassSession#get</literal> operation).
       </para>
       
       <para>
          In order to support this, Compass must be configured with how to parse the xml content into an <literal>XmlObject</literal>, and how to convert an <literal>XmlObject</literal> into an xml string. Compass comes with built in converters that do exactly that:
          
          <table>
            <tgroup cols="2">
              <colspec colname="c1" colwidth="3*" />
              <colspec colname="c2" colwidth="5*" />
              <thead>
                <row><entry>XmlContentConverter</entry><entry>Description</entry></row>
              </thead>
              <tbody>
                <row>
                  <entry>org.compass.core.xml.javax.converter.NodeXmlContentConverter</entry>
                  <entry>Support for JSE 5 xml libraries. Not recommended on account of performance.</entry>
                </row>
                <row>
                  <entry>org.compass.core.xml.dom4j.converter.SAXReaderXmlContentConverter</entry>
                  <entry>Support dom4j <literal>SAXReader</literal> for parsing, and <literal>XMLWriter</literal> to write the raw xml data.</entry>
                </row>
                <row>
                  <entry>org.compass.core.xml.dom4j.converter.XPPReaderXmlContentConverter</entry>
                  <entry>Support dom4j <literal>XPPReader</literal> for parsing, and <literal>XMLWriter</literal> to write the raw xml data.</entry>
                </row>
                <row>
                  <entry>org.compass.core.xml.dom4j.converter.XPP3ReaderXmlContentConverter</entry>
                  <entry>Support dom4j <literal>XPP3Reader</literal> for parsing, and <literal>XMLWriter</literal> to write the raw xml data.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          
       </para>
       
       <para>
          Most of the time, better performance can be achieved by pooling <literal>XmlContentConverter</literal>s implementations. Compass handling of <literal>XmlContentConverter</literal> allows for three different instantiation models: prototype, pool, and singleton. prototype will create a new <literal>XmlContentConverter</literal> each time, a singleton will use a shared <literal>XmlContentConverter</literal> for all operations, and pooled will pool <literal>XmlContentConverter</literal> instances. The default is prototype.
       </para>
       
       <para>
          Here is an example of a Compass schema based configuration that registers a global Xml Content converter:
<programlisting><![CDATA[<compass-core-config ...
   <compass name="default">

       <connection>
           <file path="target/test-index" />
       </connection>

       <converters>
           <converter name="compass.converter.xmlContentMapping" 
              type="org.compass.core.converter.mapping.xsem.XmlContentMappingConverter">
              <setting name="xmlContentConverter.type" value="[fully qualified class name of XmlContentConverter]" />
              <setting name="xmlContentConverter.wrapper" value="prototype" />
           </converter>
       </converters>

   </compass>
</compass-core-config>
]]></programlisting>
       </para>    
       <para>
          And here is an example of a DTD (settings) based configuration file:
<programlisting><![CDATA[<!DOCTYPE compass-core-configuration PUBLIC ...
<compass-core-configuration>
   <compass>
      <setting name="compass.converter.xmlContentMapping.type">
         org.compass.core.converter.mapping.xsem.XmlContentMappingConverter
      </setting>
      <setting name="compass.converter.xmlContentMapping.xmlContentConverter.type">
         [fully qualified class name of XmlContentConverter]
      </setting>
      <setting name="compass.converter.xmlContentMapping.xmlContentConverter.wrapper">
         prototype
      </setting>
   </compass>
</<compass-core-configuration>   
]]></programlisting>
       </para>
       <para>
          And last, here is how it can be configured it programmatically:
<programlisting><![CDATA[settings.setGroupSettings(CompassEnvironment.Converter.PREFIX,
   CompassEnvironment.Converter.DefaultTypeNames.Mapping.XML_CONTENT_MAPPING,
   new String[]{CompassEnvironment.Converter.TYPE, CompassEnvironment.Converter.XmlContent.TYPE},
   new String[]{XmlContentMappingConverter.class.getName(), XPP3ReaderXmlContentConverter.class.getName()});
]]></programlisting>
       </para>
    </sect1>
    
    <sect1 id="xsem-rawxmlobject-def">
       <title>Raw Xml Object</title>

       <para>
          If Compass is configured with an Xml Content converter, it now knows how to parse an xml content into an <literal>XmlObject</literal>. This allows us to simplify more the creation of <literal>XmlObject</literal>s from a raw xml data. Compass comes with a wrapper <literal>XmlObject</literal> implementation, which handles raw xml data (non parsed one). Here is how it can be used:
<programlisting><![CDATA[Reader xmlData = // construct an xml reader over raw xml content
AliasedXmlObject xmlObject = RawAliasedXmlObject(alias, xmlData);
session.save(xmlObject);                         
]]></programlisting>
       </para>
       <para>
          Here, Compass will identify that it is a <literal>RawAliasedXmlObject</literal>, and will used the registered converter (or the one configured against the <literal>xml-content</literal> mapping for the given alias) to convert it to the appropriate <literal>XmlObject</literal> implementation. Note, that when performing any read/search operation, the actual <literal>XmlObject</literal> that will be returned is the onc the the registered converter creates, and not the raw xml object.
       </para>
    </sect1>
</chapter>
